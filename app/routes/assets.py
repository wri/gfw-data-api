from typing import Optional, List, Dict, Any
from uuid import UUID

from fastapi import APIRouter, Depends, Path, HTTPException, Response
from fastapi.responses import ORJSONResponse

from ..models.orm.asset import Asset as ORMAsset
from ..models.pydantic.asset import Asset, AssetCreateIn
from ..models.pydantic.change_log import ChangeLog
from ..routes import dataset_dependency, is_admin, version_dependency


router = APIRouter()

# TODO:
#  - Assets should have config parameters to allow specifying creation options
#  -- might be good to have different endpoints for different asset types to be able to validate config params?


@router.get(
    "/{dataset}/{version}/assets",
    response_class=ORJSONResponse,
    tags=["Assets"],
    response_model=List[Asset],
)
async def get_assets(
    *,
    dataset: str = Depends(dataset_dependency),
    version: str = Depends(version_dependency),
):
    """
    Get all assets for a given dataset version
    """
    pass


@router.get(
    "/{dataset}/{version}/assets/{asset_id}",
    response_class=ORJSONResponse,
    tags=["Assets"],
    response_model=Asset,
)
async def get_asset(
    *,
    dataset: str = Depends(dataset_dependency),
    version: str = Depends(version_dependency),
    asset_id: UUID = Path(...),
):
    """
    Get a specific asset
    """
    pass


@router.get(
    "/assets",
    response_class=ORJSONResponse,
    tags=["Assets"],
    response_model=List[Asset],
)
async def get_assets_root(*, asset_id: UUID = Path(...)):
    """
    Get a specific asset
    """
    pass


@router.get(
    "assets/{asset_id}",
    response_class=ORJSONResponse,
    tags=["Assets"],
    response_model=Asset,
)
async def get_asset_root(*, asset_id: UUID = Path(...)):
    """
    Get a specific asset
    """
    pass


@router.post(
    "/{dataset}/{version}/assets",
    response_class=ORJSONResponse,
    tags=["Assets"],
    response_model=Asset,
    status_code=201,
)
async def add_new_asset(
    *,
    dataset: str = Depends(dataset_dependency),
    version: str = Depends(version_dependency),
    request: Optional[AssetCreateIn],
    is_authorized: bool = Depends(is_admin),
    response: Response,
):
    """
    Add a new asset to a dataset version. Managed assets will be generated by the API itself.
    In that case, the Asset URI is read only and will be set automatically.

    If the asset is not managed, you need to specify an Asset URI to link to.
    """
    # row: ORMAsset = ...
    # response.headers["Location"] = f"/{dataset}/{version}/asset/{row.asset_id}"
    # return row
    pass


@router.delete(
    "/{dataset}/{version}/assets/{asset_id}",
    response_class=ORJSONResponse,
    tags=["Assets"],
    response_model=Asset,
)
async def delete_asset(
    *,
    dataset: str = Depends(dataset_dependency),
    version: str = Depends(version_dependency),
    asset_id: UUID = Path(...),
    is_authorized: bool = Depends(is_admin),
):
    """
    Delete selected asset.
    For managed assets, all resources will be deleted. For non-managed assets, only the link will be deleted.
    """
    pass


@router.post("/{dataset}/{version}/{asset_id}/change_log", tags=["Assets"])
async def asset_history(
    *,
    dataset: str = Depends(dataset_dependency),
    version: str = Depends(version_dependency),
    asset_id: UUID = Path(...),
    request: ChangeLog,
    is_authorized: bool = Depends(is_admin),
):
    """
    Log changes for given asset
    """
    row = await _get_asset(asset_id)
    change_log = row.change_log
    change_log.append(request.dict())

    row = await row.update(change_log=change_log).apply()

    return await _asset_response(row)


async def _get_asset(asset_id: UUID) -> ORMAsset:
    """
    Fetch asset data, if exists
    """
    row: ORMAsset = await ORMAsset.get([asset_id])
    if row is None:
        raise HTTPException(
            status_code=404, detail=f"Asset with id {asset_id} does not exists",
        )
    return row


async def _asset_response(data: ORMAsset) -> Dict[str, Any]:
    """
    Serialize ORM response
    """
    response = Asset.from_orm(data).dict(by_alias=True)
    return response
